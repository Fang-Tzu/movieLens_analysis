---
title: "Report - movieLens dataset analysis"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=F, warning=F, cache=T)
```

## Introduction

> Note: The sources are available [here](https://github.com/redroy44/movieLens_analysis).

This is a report on the movieLens dataset available [here](https://grouplens.org/datasets/movielens/). MovieLens itself is a research site run by GroupLens Research group at the University of Minnesota. An interesting thing to notice is that the first automated recommender system was developed there in 1993.

### Objectives

The movieLens dataset is most often used for the purpose of recommender systems. Their purpose is to predict user movie ratings based on other users' ratings. In other words we expect that user with similar taste will tend to rate movies with high correlation. 

However, in this analysis we will try to explore the movies themselves. Hopefully it will give us an interesting insight into the history of cinematography.

### Packages used

For this analysis the Microsoft R Open distribution was used. The reason for this was its multithreaded performance as described [here](https://mran.microsoft.com/documents/rro/multithread/). Most of the packages that were used come from the [tidyverse](http://tidyverse.org/) - a collection of packages that share common philosophies of tidy data. The tidytext and wordcloud packages were used for some text processing. Finally the doMC package was used to embrace the multithreading in some of the custom functions which will be described later. 

> Note: doMC package is not available on Windows. Use doParallel package instead.

```{r packages, results='hide'}
# Load the packages -------------------------------------------------------
library(checkpoint)
checkpoint("2017-01-15", auto.install.knitr=T)
library(tidyverse)
library(lubridate)
library(stringr)
library(rvest)
library(XML)
library(tidytext)
library(wordcloud)
library(doMC)
registerDoMC()
set.seed(29082012)
```

The output of sessionInfo() is placed here for reproducibility purposes.
```{r, echo=T}
# Print Session Information
sessionInfo()
```

## Dataset Description

The dataset is avaliable in several snapshots. The ones that were used in this analysis were Latest Datasets - both full and small (for testing purposes). They were last updated in October 2016.

First the data was automatically downloaded and unzipped. 

###Dataset Download

First the data was automatically downloaded and unzipped. Although it is generally done only once during the analysis, it makes the reproducibility so much easier and less painful.

```{r, echo=T}
url <- "http://files.grouplens.org/datasets/movielens/"
dataset_small <- "ml-latest-small"
dataset_full <- "ml-latest"
data_folder <- "data"
archive_type <- ".zip"

# Choose dataset version
dataset <- dataset_full
dataset_zip <- paste0(dataset, archive_type)

# Download the data and unzip it
if (!file.exists(file.path(data_folder, dataset_zip))) {
  download.file(paste0(url, dataset_zip), file.path(data_folder, dataset_zip))
}
unzip(file.path(data_folder, dataset_zip), exdir = data_folder, overwrite = F)

# Display the unzipped files
list.files('data/', recursive=T)
```
### Loading the Dataset

The dataset is split into four files (genome-scores.csv and genome-tags.csv were omitted for this analysis)- movies.csv, ratings.csv, links.csv and tags.csv. We will iteratively load the files into the workspace using read_csv() function and assign variable names accordingly. The read_csv() function is very convenient because it automagically guesses column types based on the first thousand rows. And more importantly it never converts strings to factors. Never. 

Finally we will check object sizes to see how big is the dataset.
```{r, echo=T}
dataset_files <- c("movies", "ratings", "links", "tags")
suffix <- ".csv"

for (f in dataset_files) {
  path <- file.path(data_folder, dataset, paste0(f, suffix))
  assign(f, read_csv(path))
  print(paste(f, "object size is", format(object.size(get(f)),units="Mb")))
}
```

The biggest data frame is ratings - it contains movie ratings from movieLens users. Next we will see what kind of data we deal with.

## Data Cleaning

In this section we will take the first look at the loaded data frames. We will also perform necessary cleaning and some transformations so that the data better suits our needs. First, let's look at the ratings table.

```{r}
# Clean ratings
glimpse(ratings)
```

We have 24 millions rows and 4 columns. It seems that only timestamp column need to be parsed. We will create new data frame that we will work on and preserve the original data frame (treat it as read-only).

```{r}
ratings_df <- ratings %>%
  mutate(timestamp = as_datetime(timestamp))

summary(ratings_df)
```

Ok, looks like there is no missing data. We can also see that the ratings range from 0.5 to 5 and that they are timestamped. Now, let's look into the movies data frame.

```{r}
glimpse(movies)
```
There are 40 thousand movies and 3 columns. Most of the movies have their debut year added to their names - we want to extract this into separate columns. Genres columns contains multiple categories per row - we want to have them separated into one category per row. We will deal with this later.
```{r warning=T}
movies_df <- movies %>%
  mutate(title = str_trim(title)) %>% # trim whitespaces
  extract(title, c("title_tmp", "year"), regex = "^(.*) \\(([0-9 \\-]*)\\)$", remove = F) %>% # split title to title, year
  mutate(year = if_else(str_length(year) > 4, as.integer(str_split(year, "-", simplify = T)[1]), as.integer(year))) %>% # for series take debut date
  mutate(title = if_else(is.na(title_tmp), title, title_tmp)) %>% # replace title NA's with original title
  select(-title_tmp)  %>%# drop title_tmp column
  mutate(genres = if_else(genres == "(no genres listed)", `is.na<-`(genres), genres)) # generic function to turn (no genres listed) to NA
```
Here we extracted the movie debut year using extract() function from tidyr package. For the case of movie series where year has "yyyy-yyyy" format we take the first date. In the last line we replaced the string "(no genres listed)" with NA value to make further processing easier.

The warnings() functions returned a message that some missing values appeared. 

```{r}
# Check NA's
na_movies <- movies_df %>%
  filter(is.na(title) | is.na(year)) %>%
  print
```
Seems that warnings appeared, because some of the movies do not have their debut year. We will ignore those movies in further analysis as there aren't many of them.

```{r}
summary(movies_df)
```

Let's check the tags data frame now.
```{r}
glimpse(tags)
```
Seems that only timestamp needs to be parsed.
```{r}
tags_df <- tags %>%
  mutate(timestamp = as_datetime(timestamp))

summary(tags_df)
```

No missing values, we can continue to the links data frame.

```{r}
glimpse(links)
```

We have 40,000 rows with ids to imdb and tmdb websites. We will use them later for some web scraping.

Ok, we are now done with data cleaning. Let's go deeper into the data exploration.


## Data Exploration

In this part we will try to explore the dataset and reveal some interesting facts about cinematography.

### How many movies were produced per year?
The first question that may be asked is how many movies were produced year by year. We can easily extract this information from the movies_df data frame.
```{r q1-1}
# Number of movies per year/decade
movies_per_year <- movies_df %>%
  na.omit() %>% # omit missing values
  select(movieId, year) %>% # select columns we need
  group_by(year) %>% # group by year
  summarise(count = n())  %>% # count movies per year
  arrange(count) %>%
  print()
```
There are some years that are missing, probably there were no movies produced in the early years. We can easily fix missing values using complete() function from the tidyr package.
```{r}
# fill missing years
movies_per_year <- movies_per_year %>%
  complete(year = full_seq(year, 1), fill = list(count = 0)) %>%
  print()
```
 
 That's better. Now let's plot what we have.
```{r q1-2}
movies_per_year %>%
  ggplot(aes(x = year, y = count)) +
  geom_line(color="blue")
```

We can see an exponential growth in the '90s and a sudden drop in 2016. The latter is caused by the fact that the data is collected until October 2016 so we don't have the full data on this year. As for the former, perhaps it was somewhat linked to the beginning of the information era. Growing popularity of the Internet must have had a positive impact on the demand for movies. That is certainly something worthy of further analysis.


### What were the most popular movie genres year by year?
We know how many movies were produced, but can we check what genres were popular? We might expect that some events in history might have influenced the movie creators to produce specific genres. First we will check what genres are the most popular in general.

```{r}
genres_df <- movies_df %>%
  separate_rows(genres, sep = "\\|") %>%
  group_by(genres) %>%
  summarise(number = n()) %>%
  arrange(desc(number)) %>%
  print()
```

No suprise here. Dramas and comedies are definitely the most popular genres.

```{r q2-1}
# Genres popularity per year
genres_popularity <- movies_df %>%
  na.omit() %>% # omit missing values
  select(movieId, year, genres) %>% # select columns we are interested in
  separate_rows(genres, sep = "\\|") %>% # separate genres into rows
  mutate(genres = as.factor(genres)) %>% # turn genres in factors
  group_by(year, genres) %>% # group data by year and genre
  summarise(number = n()) %>% # count
  complete(year = full_seq(year, 1), genres, fill = list(number = 0)) # add missing years/genres
```
Now we are able to plot the data. For readability I chose 4 genres: animation, sci-fi, war and western movies.
```{r q2-2, results=F, echo=F}
# Most popular genres
genres_top <- genres_popularity %>%
  group_by(genres) %>%
  summarise(number = sum(number)) %>%
  arrange(desc(number)) %>%
  top_n(10, number)
```

```{r q2-3}
genres_popularity %>%
  filter(year > 1930) %>%
  filter(genres %in% c("War", "Sci-Fi", "Animation", "Western")) %>%
  ggplot(aes(x = year, y = number)) +
    geom_line(aes(color=genres)) + 
    scale_fill_brewer(palette = "Paired") 
```

Here we have some interesting observations. First we can notice a rapid growth of sci-fi movies shortly after 1969, the year of the first Moon landing. Secondly we high number of westerns in 1950s and 1960s that was the time when westerns popularity was peaking. Nest we can see the rise of popularity of animated movies, the most probable reason might be the computer animation technology advancement which made the production much easier. War movies were popular around the time when big miliraty conflicts occured - World War II, Vietnam War and most recently War in Afghanistan and Iraq. It interesting to see how the world of cinematography reflected the state of the real world.


### What tags best summarize a movie genre? {.tabset .tabset-fade .tabset-pills}
Looking at how each movie genre is tagged by users is a great way to see if a movie genre can be described using just a few words. We'll explore a selection of movie genres and see if anything interesting pops out.

```{r q3-1}
# Tags for genres
genres_tags <- movies_df %>%
  na.omit() %>%
  select(movieId, year, genres) %>%
  separate_rows(genres, sep = "\\|") %>%
  inner_join(tags_df, by = "movieId") %>%
  select(genres, tag) %>%
  group_by(genres) %>%
  nest()
```

Click on a tab to see a tagcloud for a selected genre.

#### Action

```{r q3-2}
# plot wordcloud per genre
genre<-"Action"
genre_words <- genres_tags %>%
  filter(genres == genre) %>%
  unnest() %>%
  mutate(tag = str_to_lower(tag, "en")) %>%
  anti_join(tibble(tag=c(tolower(genre)))) %>%
  count(tag)

  wordcloud(genre_words$tag, genre_words$n, max.words = 50, colors=brewer.pal(8, "Dark2"))

```

<!-- Looks like action movies involve sci-fi dystopic world where a superhero is needed. We can also see Bruce Willis and Harrison Ford as synonyms for the genre, well you can't argue with that. -->

#### Comedy

```{r q3-3}
# plot wordcloud per genre
genre<-"Comedy"
genre_words <- genres_tags %>%
  filter(genres == genre) %>%
  unnest() %>%
  mutate(tag = str_to_lower(tag, "en")) %>%
  anti_join(tibble(tag=c(tolower(genre)))) %>%
  count(tag)

  wordcloud(genre_words$tag, genre_words$n, max.words = 50, colors=brewer.pal(8, "Dark2"))

```

<!-- The most popular comedy would a dark/black comedy that is quirky, satiric and takes place in high school. We can also see Bill Murray, Tom Hanks and Jim Carrey as actors who characterize the genre. -->

#### Drama
<!-- throw out -->
```{r q3-4}
# plot wordcloud per genre
genre<-"Drama"
genre_words <- genres_tags %>%
  filter(genres == genre) %>%
  unnest() %>%
  mutate(tag = str_to_lower(tag, "en")) %>%
  anti_join(tibble(tag=c(tolower(genre)))) %>%
  count(tag)

  wordcloud(genre_words$tag, genre_words$n, max.words = 50, colors=brewer.pal(8, "Dark2"))

```



#### Thriller

```{r q3-5}
# plot wordcloud per genre
genre<-"Thriller"
genre_words <- genres_tags %>%
  filter(genres == genre) %>%
  unnest() %>%
  mutate(tag = str_to_lower(tag, "en")) %>%
  anti_join(tibble(tag=c(tolower(genre)))) %>%
  count(tag)

  wordcloud(genre_words$tag, genre_words$n, max.words = 50, colors=brewer.pal(8, "Dark2"))

```

<!-- Looks like the best thriller would be full of action and violence, starring Brruce Willis and Brad Pitt nad taking place in a surreal, sci-fi reality. -->

#### Horror

```{r q3-6}
# plot wordcloud per genre
genre<-"Horror"
genre_words <- genres_tags %>%
  filter(genres == genre) %>%
  unnest() %>%
  mutate(tag = str_to_lower(tag, "en")) %>%
  anti_join(tibble(tag=c(tolower(genre)))) %>%
  count(tag)

  wordcloud(genre_words$tag, genre_words$n, max.words = 50, colors=brewer.pal(8, "Dark2"))

```

<!-- What is a recipe for a good horror? Serial killers and aliens in a post-apocalyptic world. With a plot containing a lot of suspension, twist ending with a hint of nudity. -->

#### Children

```{r q3-7}
# plot wordcloud per genre
genre<-"Children"
genre_words <- genres_tags %>%
  filter(genres == genre) %>%
  unnest() %>%
  mutate(tag = str_to_lower(tag, "en")) %>%
  anti_join(tibble(tag=c(tolower(genre), "animation"))) %>%
  count(tag)

  wordcloud(genre_words$tag, genre_words$n, max.words = 50, colors=brewer.pal(8, "Dark2"))

```

<!-- As for chldren movies, we can see that the genre is dominated by Disney and Pixar companies. Most children movies include funny talking animals and are based on books. -->

#### Crime

```{r q3-8}
# plot wordcloud per genre
genre<-"Crime"
genre_words <- genres_tags %>%
  filter(genres == genre) %>%
  unnest() %>%
  mutate(tag = str_to_lower(tag, "en")) %>%
  anti_join(tibble(tag=c(tolower(genre)))) %>%
  count(tag)

  wordcloud(genre_words$tag, genre_words$n, max.words = 50, colors=brewer.pal(8, "Dark2"))

```

<!-- Crime movies are often related to comedies and as expected they often end with a plot twist. -->

#### Romance
<!-- throw out -->
```{r q3-9}
# plot wordcloud per genre
genre<-"Romance"
genre_words <- genres_tags %>%
  filter(genres == genre) %>%
  unnest() %>%
  mutate(tag = str_to_lower(tag, "en")) %>%
  anti_join(tibble(tag=c(tolower(genre)))) %>%
  count(tag)

  wordcloud(genre_words$tag, genre_words$n, max.words = 50, colors=brewer.pal(8, "Dark2"))

```


### What were the best movies of every decade (based on users' ratings)?
```{r q4}
# average rating for a movie

avg_rating <- ratings_df %>%
  inner_join(movies_df, by = "movieId") %>%
  na.omit() %>%
  select(movieId, title, rating, year) %>%
  group_by(movieId, title, year) %>%
  summarise(count = n(), mean = mean(rating), min = min(rating), max = max(rating)) %>%
  ungroup() %>%
  arrange(count, desc(mean))
```

```{r, warning=T, message=T}
# Lower bound of Wilson score confidence interval for a Bernoulli parameter
# http://www.evanmiller.org/how-not-to-sort-by-average-rating.html
# movies with the same mean but more reviews get higher score
ci_lower <- function(pos, n, confidence) {
  z = qnorm(1-(1-confidence)/2)
  phat = pos
  return (phat + z*z/(2*n) - z * sqrt((phat*(1-phat)+z*z/(4*n))/n))/(1+z*z/n)
}

avg_rating <- avg_rating %>%
  mutate(score = ci_lower(mean/5, count, 0.95)) %>%
  arrange(desc(score))

# find best movie of a decade based on score
# heavily dependent on the number of reviews
best_per_decade <- avg_rating %>%
  filter(count > 3) %>% # at least the median number of reviews (3)
  mutate(decade = year  %/% 10 * 10) %>%
  arrange(year, desc(score)) %>%
  group_by(decade) %>%
  summarise(title = first(title), score = first(score), mean = first(mean), count = first(count))
  print(best_per_decade)
```

### What were the best years for a genre (based on users' ratings)?
```{r q5-1}
genres_rating <- movies_df %>%
  na.omit() %>%
  select(movieId, year, genres) %>%
  inner_join(ratings_df, by = "movieId") %>%
  select(-timestamp, -userId) %>%
  mutate(decade = year  %/% 10 * 10) %>%
  separate_rows(genres, sep = "\\|") %>%
  group_by(year, genres) %>%
  summarise(count = n(), avg_rating = mean(rating)) %>%
  ungroup() %>%
  mutate(score = ci_lower(avg_rating/5, count, 0.95)) %>%
  arrange(year)
```
```{r q5-2}
genres_rating %>%
  #filter(genres %in% genres_top$genres) %>%
  filter(genres %in% c("Action", "Romance", "Sci-Fi", "Western")) %>%
  ggplot(aes(x = year, y = score)) +
    geom_line(aes(group=genres, color=genres)) +
    geom_smooth(aes(group=genres, color=genres)) +
    facet_wrap(~genres)
```

## Web Scraping
In the final part of the dataset exploration I used a handful of functions for performing web scraping from IMDB website using the data from links data frame. 
An example function looks like the one below. The `%dopar%` operator enables parallel processing that greatly speeds up the computations.
```{r, eval=F}
# Get movie cast ----------------------------------------------------------
get_cast <- function(link) {
  cast <- foreach(d=iter(link, by='row'), .combine=rbind) %dopar% {
    tmp <- d %>%
      read_html() %>%
      html_nodes("#titleCast .itemprop span") %>%
      html_text(trim = T) %>%
      paste(collapse="|")
  }
  rownames(cast) <- c()
  return(as.vector(cast))
}
```

Next, we'll prepare a new data frame that will contain explicit links to imdb website and run basic tests to verify if the functions work.
```{r , results='hold'}
# source utility functions
source(file = "functions.R")

imdb_url = "http://www.imdb.com/title/tt"

imdb_df <- movies_df %>%
  inner_join(links, by = "movieId") %>%
  select(-tmdbId) %>%
  mutate(link = paste0(imdb_url, imdbId))

# Quick check for Toy Story and Star Wars V
get_cast(c("http://www.imdb.com/title/tt0114709", "http://www.imdb.com/title/tt0076759"))
get_budget(c("http://www.imdb.com/title/tt0114709", "http://www.imdb.com/title/tt0076759"))
get_director(c("http://www.imdb.com/title/tt0114709", "http://www.imdb.com/title/tt0076759"))
get_time(c("http://www.imdb.com/title/tt0114709", "http://www.imdb.com/title/tt0076759"))
```
Ok, looks like it works! We can now download the data for the whole `imdb_df` data frame.

```{r, eval=FALSE}
imdb_df <- imdb_df %>%
  mutate(time = get_time(link)) %>%
  mutate(director = get_director(link)) %>%
  mutate(budget = get_budget(link)) %>%
  mutate(cast = get_cast(link))
```
```{r, echo=F}
imdb_df <- read_csv('imdb_df.csv')
```
Finally, we'll add `score` column from the `avg_rating` data frame.
```{r}
imdb_df <- imdb_df %>%
  inner_join(avg_rating, by = c('movieId', 'title', 'year')) %>%
  select(-min, -max, -genres, -count)
```

### Does a movie budget affect its score?
```{r q6}
imdb_df %>%
  #filter(budget < 1e10) %>%
  ggplot(aes(x=log(budget), y=score)) +
    geom_point(color="blue")

# check correlation coefficient
cor(imdb_df$budget, imdb_df$score, use = "na.or.complete")
```

The scatterplot doesn't show any particular pattern and the correlation coefficient is close to 0. If it's not the moeny then what is it?

### What is the optimal movie running time?
```{r q7}
imdb_df %>%
  filter(time < 200) %>%
  ggplot(aes(x=time, y=score)) +
    geom_point(color="blue")

# check correlation coefficient
#cor(imdb_df$budget, imdb_df$score, use = "na.or.complete")
```

Interesting. We can see a triangular shape suggesting that longer movies are less likely to get low score. There is also a suggestion that very short movies tend to score higher.

### Who is the best movie director?
```{r}
best_director <- imdb_df %>%
  inner_join(movies_df, by = "movieId") %>%
  na.omit() %>%
  select(director, score, mean) %>%
  separate_rows(director, sep = "\\|") %>%
  group_by(director) %>%
  summarise(count = n(), avg_rating = mean(mean)) %>%
  mutate(score = ci_lower(avg_rating/5, count, 0.95)) %>%
  filter(count > 3) %>%
  arrange(desc(score), count)

print(best_director)
```

### What cast is the ultimate movie cast?
```{r}
best_cast <- imdb_df %>%
  inner_join(movies_df, by = "movieId") %>%
  na.omit() %>%
  select(cast, score, mean) %>%
  separate_rows(cast, sep = "\\|") %>%
  group_by(cast) %>%
  summarise(count = n(), avg_rating = mean(mean)) %>%
  mutate(score = ci_lower(avg_rating/5, count, 0.95)) %>%
  filter(count > 3) %>%
  arrange(desc(score), count)

print(best_cast)
```

## Conclusion
